
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kindergarten Sight Words Matching Game</title>
  <style>
    :root{
      --bg1:#f7fbff;
      --bg2:#fff7fb;
      --card:#ffffff;
      --ink:#1f2937;
      --muted:#6b7280;
      --good:#16a34a;
      --bad:#dc2626;
      --accent:#2563eb;
      --accent2:#9333ea;
      --shadow: 0 10px 30px rgba(0,0,0,.10);
      --round: 22px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--ink);
      background: radial-gradient(1200px 600px at 20% 0%, var(--bg2), transparent 70%),
                  radial-gradient(1000px 500px at 80% 10%, var(--bg1), transparent 70%),
                  linear-gradient(180deg, #fff, #f6fbff);
      min-height:100vh;
    }
    header{
      padding:18px 18px 8px;
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:12px;
      justify-content:space-between;
    }
    .titleWrap{
      display:flex;
      align-items:center;
      gap:12px;
    }
    .badge{
      width:52px;height:52px;border-radius:16px;
      background: conic-gradient(from 180deg, #22c55e, #3b82f6, #a855f7, #f97316, #22c55e);
      box-shadow: var(--shadow);
      position:relative;
      flex:0 0 auto;
    }
    .badge::after{
      content:"Aa";
      position:absolute; inset:0;
      display:grid; place-items:center;
      font-weight:900;
      color:white;
      text-shadow:0 2px 10px rgba(0,0,0,.25);
      font-size:22px;
    }
    h1{
      margin:0;
      font-size: clamp(20px, 2.5vw, 30px);
      letter-spacing:-0.5px;
      line-height:1.1;
    }
    .sub{
      margin:2px 0 0;
      color:var(--muted);
      font-size: clamp(12px, 1.4vw, 14px);
    }

    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
    }

    .pill{
      background: rgba(255,255,255,.7);
      border: 1px solid rgba(0,0,0,.08);
      border-radius: 999px;
      padding: 10px 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,.06);
      display:flex;
      gap:10px;
      align-items:center;
      backdrop-filter: blur(8px);
    }
    label{ font-size:14px; color:var(--muted); }
    select, button, input[type="checkbox"]{
      font-size:16px;
    }
    select{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(0,0,0,.12);
      background:white;
      min-width: 160px;
      touch-action: manipulation;
    }
    .btn{
      padding:12px 14px;
      border-radius:16px;
      border:1px solid rgba(0,0,0,.12);
      background:white;
      cursor:pointer;
      box-shadow: 0 8px 18px rgba(0,0,0,.08);
      font-weight:800;
      touch-action: manipulation;
      user-select:none;
    }
    .btn.primary{
      border:none;
      color:white;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
    }
    .btn:active{ transform: translateY(1px) scale(.99); }

    main{
      padding: 10px 18px 22px;
      display:grid;
      gap:16px;
    }

    .board{
      background: rgba(255,255,255,.78);
      border:1px solid rgba(0,0,0,.08);
      border-radius: var(--round);
      box-shadow: var(--shadow);
      padding: 16px;
      position:relative;
      overflow:hidden;
    }

    .topRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-bottom: 10px;
    }
    .status{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .chip{
      padding:10px 12px;
      border-radius: 999px;
      background: rgba(37,99,235,.10);
      border:1px solid rgba(37,99,235,.18);
      font-weight:800;
      font-size:15px;
    }
    .chip.good{
      background: rgba(22,163,74,.12);
      border-color: rgba(22,163,74,.22);
    }
    .chip.bad{
      background: rgba(220,38,38,.10);
      border-color: rgba(220,38,38,.18);
    }

    .layout{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 820px){
      .layout{ grid-template-columns:1fr; }
    }
    .colTitle{
      margin: 6px 0 10px;
      font-size: 16px;
      color: var(--muted);
      font-weight: 800;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }

    .grid{
      display:grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }

    .cardBtn{
      width:100%;
      border:none;
      border-radius: 22px;
      padding: 18px 16px;
      background: white;
      box-shadow: 0 10px 22px rgba(0,0,0,.10);
      cursor:pointer;
      text-align:center;
      touch-action: manipulation;
      user-select:none;
      position:relative;
      overflow:hidden;
      min-height: 84px;
      display:grid;
      place-items:center;
      transition: transform .10s ease, box-shadow .10s ease;
    }
    .cardBtn:hover{
      transform: translateY(-1px);
      box-shadow: 0 14px 26px rgba(0,0,0,.12);
    }
    .cardBtn:active{
      transform: translateY(1px) scale(.99);
    }

    .word{
      font-weight: 1000;
      font-size: clamp(34px, 4.0vw, 54px);
      letter-spacing: 1px;
      text-transform:none;
    }

    .pic{
      font-size: clamp(34px, 4.0vw, 54px);
      font-weight: 1000;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 12px;
    }
    .small{
      font-size: 14px;
      color: var(--muted);
      font-weight:800;
      margin-top: 6px;
    }
    .hintTag{
      font-size: 13px;
      font-weight:900;
      color: rgba(0,0,0,.55);
      background: rgba(0,0,0,.06);
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid rgba(0,0,0,.08);
      white-space:nowrap;
    }

    .selected{
      outline: 6px solid rgba(37,99,235,.35);
      box-shadow: 0 16px 30px rgba(37,99,235,.18);
    }

    .matched{
      opacity:.55;
      filter: grayscale(.2);
    }

    .correctFlash{
      animation: popGood .55s ease;
    }
    @keyframes popGood{
      0%{ transform: scale(1); }
      35%{ transform: scale(1.05); }
      100%{ transform: scale(1); }
    }

    .wrongShake{
      animation: shake .45s ease;
    }
    @keyframes shake{
      0%,100%{ transform: translateX(0); }
      20%{ transform: translateX(-8px); }
      40%{ transform: translateX(8px); }
      60%{ transform: translateX(-6px); }
      80%{ transform: translateX(6px); }
    }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: rgba(17,24,39,.92);
      color:white;
      padding: 12px 14px;
      border-radius: 16px;
      box-shadow: 0 14px 32px rgba(0,0,0,.25);
      font-weight: 900;
      letter-spacing:.2px;
      opacity:0;
      pointer-events:none;
      transition: opacity .2s ease, transform .2s ease;
      max-width: min(560px, 92vw);
      text-align:center;
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-6px);
    }

    /* Confetti Canvas sits above board */
    canvas#confetti{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }

    .footerRow{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px dashed rgba(0,0,0,.14);
    }
    .turn{
      font-weight: 900;
      color: var(--muted);
    }
    .toggleWrap{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight:900;
      color: var(--muted);
    }
    .toggleWrap input{ width:20px; height:20px; }
    .mini{
      font-size:13px;
      color: var(--muted);
      font-weight:800;
    }

    /* Accessibility / focus */
    button:focus-visible, select:focus-visible, input:focus-visible{
      outline: 4px solid rgba(147,51,234,.35);
      outline-offset: 2px;
    }
  </style>
</head>
<body>
  <header>
    <div class="titleWrap">
      <div class="badge" aria-hidden="true"></div>
      <div>
        <h1>Kindergarten Sight Words Matching Game</h1>
        <p class="sub">Tap a word, then tap the matching picture/sound button. Big buttons for smartboards.</p>
      </div>
    </div>

    <div class="controls">
      <div class="pill">
        <label for="levelSelect"><strong>Level</strong></label>
        <select id="levelSelect" aria-label="Select level">
          <option value="1">Level 1 (4â€“5 words)</option>
          <option value="2">Level 2 (6â€“8 words)</option>
          <option value="3">Level 3 (10+ words)</option>
        </select>
      </div>

      <button id="nextRoundBtn" class="btn primary" type="button">New Round</button>
      <button id="resetBtn" class="btn" type="button">Reset Game</button>
    </div>
  </header>

  <main>
    <section class="board" aria-label="Game board">
      <canvas id="confetti"></canvas>

      <div class="topRow">
        <div class="status">
          <div class="chip" id="roundChip">Round: 1</div>
          <div class="chip" id="scoreChip">Score: 0</div>
          <div class="chip good" id="correctChip">Correct: 0</div>
          <div class="chip bad" id="wrongChip">Try Again: 0</div>
        </div>

        <div class="toggleWrap">
          <input type="checkbox" id="turnMode" />
          <label for="turnMode">Turn-Based Class Mode</label>
          <span class="mini" id="turnInfo" aria-live="polite"></span>
        </div>
      </div>

      <div class="layout">
        <div>
          <div class="colTitle">
            <span>Words</span>
            <span class="hintTag" id="hintTag">Hints: ON</span>
          </div>
          <div class="grid" id="wordsCol" aria-label="Words column"></div>
        </div>

        <div>
          <div class="colTitle">
            <span>Match with Pictures + Sound</span>
            <span class="hintTag">Tap ðŸ”Š to hear</span>
          </div>
          <div class="grid" id="picsCol" aria-label="Pictures/sound column"></div>
        </div>
      </div>

      <div class="footerRow">
        <div class="turn" id="progressText" aria-live="polite">Make a match to start!</div>
        <div class="mini">Tip: Works with mouse or touchscreen. Audio uses your deviceâ€™s speaker.</div>
      </div>
    </section>
  </main>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>

  <script>
    /***********************
     * Sight Words Dataset *
     ***********************/
    // 20+ words (Florida KG-friendly). Images are simple emoji cues.
    const WORD_BANK = [
      { word: "I",   emoji: "ðŸ™‹â€â™€ï¸", hint: "me" },
      { word: "see", emoji: "ðŸ‘€", hint: "look" },
      { word: "like",emoji: "â¤ï¸", hint: "love" },
      { word: "can", emoji: "ðŸ’ª", hint: "able" },
      { word: "go",  emoji: "ðŸƒâ€â™‚ï¸", hint: "move" },
      { word: "we",  emoji: "ðŸ‘«", hint: "us" },
      { word: "to",  emoji: "âž¡ï¸", hint: "toward" },
      { word: "and", emoji: "âž•", hint: "plus" },
      { word: "you", emoji: "ðŸ‘‰", hint: "you" },
      { word: "it",  emoji: "ðŸ“¦", hint: "thing" },

      { word: "the", emoji: "â­", hint: "the" },
      { word: "a",   emoji: "1ï¸âƒ£", hint: "one" },
      { word: "is",  emoji: "âœ…", hint: "is" },
      { word: "my",  emoji: "ðŸ§¸", hint: "mine" },
      { word: "me",  emoji: "ðŸ™‚", hint: "me" },
      { word: "am",  emoji: "ðŸ˜Š", hint: "I am" },
      { word: "at",  emoji: "ðŸ“", hint: "spot" },
      { word: "in",  emoji: "ðŸ“¥", hint: "inside" },
      { word: "on",  emoji: "ðŸ”", hint: "top" },
      { word: "up",  emoji: "â¬†ï¸", hint: "higher" },

      // a few extra common KG words
      { word: "no",  emoji: "ðŸš«", hint: "stop" },
      { word: "yes", emoji: "ðŸ‘", hint: "okay" },
      { word: "do",  emoji: "ðŸ› ï¸", hint: "do it" },
      { word: "look",emoji: "ðŸ”Ž", hint: "see" }
    ];

    /***********************
     * Game State (Frontend)
     ***********************/
    const state = {
      level: 1,
      round: 1,
      score: 0,
      correct: 0,
      wrong: 0,
      turnMode: false,
      currentPlayer: 1,
      players: 2, // fixed for simplicity; you can change to more if you want
      selection: {
        wordId: null,
        picId: null
      },
      // current round items
      items: [], // {id, word, emoji, hint}
      matchedIds: new Set()
    };

    /***********************
     * Helpers
     ***********************/
    const $ = (sel) => document.querySelector(sel);
    const wordsCol = $("#wordsCol");
    const picsCol = $("#picsCol");
    const levelSelect = $("#levelSelect");
    const nextRoundBtn = $("#nextRoundBtn");
    const resetBtn = $("#resetBtn");
    const roundChip = $("#roundChip");
    const scoreChip = $("#scoreChip");
    const correctChip = $("#correctChip");
    const wrongChip = $("#wrongChip");
    const toastEl = $("#toast");
    const progressText = $("#progressText");
    const hintTag = $("#hintTag");
    const turnModeToggle = $("#turnMode");
    const turnInfo = $("#turnInfo");
    const confettiCanvas = $("#confetti");

    function shuffle(arr){
      const a = [...arr];
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
      }
      return a;
    }

    function levelCount(level){
      if(level === 1) return 5;          // 4â€“5 words
      if(level === 2) return 8;          // 6â€“8 words
      return 12;                         // 10+ words
    }

    function hintsOn(level){
      // Level 1: hints on. Level 2: reduced hints. Level 3: minimal assistance (hints off)
      if(level === 1) return true;
      if(level === 2) return true;
      return false;
    }

    function showToast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=> toastEl.classList.remove("show"), 1600);
    }

    /***********************
     * Audio (Web Speech + simple beeps)
     ***********************/
    function speakWord(text){
      // Prefer SpeechSynthesis for clear pronunciation
      try{
        if(!("speechSynthesis" in window)) throw new Error("No speech");
        const u = new SpeechSynthesisUtterance(text);
        u.rate = 0.85;
        u.pitch = 1.1;
        // choose an English voice if available
        const voices = speechSynthesis.getVoices?.() || [];
        const en = voices.find(v => /en/i.test(v.lang));
        if(en) u.voice = en;
        speechSynthesis.cancel();
        speechSynthesis.speak(u);
      }catch(e){
        // fallback: no-op
      }
    }

    function beep(type="good"){
      // small WebAudio tone for feedback
      const ctx = beep._ctx || (beep._ctx = new (window.AudioContext || window.webkitAudioContext)());
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      const now = ctx.currentTime;

      if(type === "good"){
        o.frequency.setValueAtTime(880, now);
        o.frequency.exponentialRampToValueAtTime(1320, now + 0.12);
        g.gain.setValueAtTime(0.08, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
      }else{
        o.frequency.setValueAtTime(220, now);
        o.frequency.exponentialRampToValueAtTime(160, now + 0.18);
        g.gain.setValueAtTime(0.07, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.22);
      }
      o.type = "sine";
      o.start(now);
      o.stop(now + 0.25);
    }

    /***********************
     * Confetti
     ***********************/
    const confetti = {
      ctx: confettiCanvas.getContext("2d"),
      particles: [],
      running: false
    };

    function resizeConfetti(){
      const rect = confettiCanvas.parentElement.getBoundingClientRect();
      confettiCanvas.width = Math.floor(rect.width * devicePixelRatio);
      confettiCanvas.height = Math.floor(rect.height * devicePixelRatio);
      confetti.ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }
    window.addEventListener("resize", resizeConfetti);

    function burstConfetti(){
      resizeConfetti();
      const rect = confettiCanvas.parentElement.getBoundingClientRect();
      const cx = rect.width/2;
      const cy = rect.height/4;

      const colors = ["#22c55e","#3b82f6","#a855f7","#f97316","#eab308","#ef4444"];
      for(let i=0;i<120;i++){
        confetti.particles.push({
          x: cx,
          y: cy,
          vx: (Math.random()-0.5)*9,
          vy: (Math.random()*-8)-3,
          g: 0.22 + Math.random()*0.12,
          r: 4 + Math.random()*4,
          rot: Math.random()*Math.PI,
          vr: (Math.random()-0.5)*0.3,
          life: 90 + Math.random()*40,
          color: colors[Math.floor(Math.random()*colors.length)]
        });
      }
      if(!confetti.running){
        confetti.running = true;
        requestAnimationFrame(tickConfetti);
      }
    }

    function tickConfetti(){
      const ctx = confetti.ctx;
      const w = confettiCanvas.parentElement.getBoundingClientRect().width;
      const h = confettiCanvas.parentElement.getBoundingClientRect().height;
      ctx.clearRect(0,0,w,h);

      confetti.particles = confetti.particles.filter(p => p.life > 0);
      for(const p of confetti.particles){
        p.life--;
        p.vy += p.g;
        p.x += p.vx;
        p.y += p.vy;
        p.rot += p.vr;

        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.r/2, -p.r/2, p.r*1.2, p.r);
        ctx.restore();
      }

      if(confetti.particles.length){
        requestAnimationFrame(tickConfetti);
      }else{
        confetti.running = false;
        ctx.clearRect(0,0,w,h);
      }
    }

    /***********************
     * Rendering
     ***********************/
    function updateHUD(){
      roundChip.textContent = `Round: ${state.round}`;
      scoreChip.textContent = `Score: ${state.score}`;
      correctChip.textContent = `Correct: ${state.correct}`;
      wrongChip.textContent = `Try Again: ${state.wrong}`;

      const hOn = hintsOn(state.level);
      hintTag.textContent = `Hints: ${hOn ? "ON" : "OFF"}`;

      if(state.turnMode){
        turnInfo.textContent = `Player ${state.currentPlayer}'s turn`;
      }else{
        turnInfo.textContent = "";
      }
    }

    function clearSelections(){
      state.selection.wordId = null;
      state.selection.picId = null;
      document.querySelectorAll(".selected").forEach(el=> el.classList.remove("selected"));
    }

    function renderRound(){
      state.matchedIds = new Set();
      clearSelections();

      wordsCol.innerHTML = "";
      picsCol.innerHTML = "";

      // left column: words (in one order)
      const wordOrder = shuffle(state.items);

      // right column: same items, shuffled independently
      const picOrder = shuffle(state.items);

      const showHints = hintsOn(state.level);

      // Words
      for(const item of wordOrder){
        const btn = document.createElement("button");
        btn.className = "cardBtn";
        btn.type = "button";
        btn.dataset.kind = "word";
        btn.dataset.id = item.id;
        btn.setAttribute("aria-label", `Word: ${item.word}`);

        const w = document.createElement("div");
        w.className = "word";
        w.textContent = item.word;

        btn.appendChild(w);

        if(showHints){
          const s = document.createElement("div");
          s.className = "small";
          s.textContent = `Hint: ${item.hint}`;
          btn.appendChild(s);
        } else if(state.level === 2){
          // reduced hints: only show on some items
          if(Math.random() < 0.45){
            const s = document.createElement("div");
            s.className = "small";
            s.textContent = `Hint: ${item.hint}`;
            btn.appendChild(s);
          }
        }

        btn.addEventListener("click", ()=> onPick("word", item.id, btn));
        btn.addEventListener("pointerdown", (e)=>{ btn.setPointerCapture?.(e.pointerId); });

        wordsCol.appendChild(btn);
      }

      // Pictures + audio
      for(const item of picOrder){
        const btn = document.createElement("button");
        btn.className = "cardBtn";
        btn.type = "button";
        btn.dataset.kind = "pic";
        btn.dataset.id = item.id;
        btn.setAttribute("aria-label", `Picture for a word`);

        const p = document.createElement("div");
        p.className = "pic";
        p.innerHTML = `<span aria-hidden="true">${item.emoji}</span> <span aria-hidden="true">ðŸ”Š</span>`;
        btn.appendChild(p);

        const s = document.createElement("div");
        s.className = "small";
        s.textContent = "Tap to hear the word";
        btn.appendChild(s);

        btn.addEventListener("click", ()=>{
          // Always speak when they tap a picture button
          speakWord(item.word);
          onPick("pic", item.id, btn);
        });
        btn.addEventListener("pointerdown", (e)=>{ btn.setPointerCapture?.(e.pointerId); });

        picsCol.appendChild(btn);
      }

      progressText.textContent = `Match all ${state.items.length} words!`;
      updateHUD();
    }

    /***********************
     * Matching Logic
     ***********************/
    function onPick(kind, id, el){
      if(state.matchedIds.has(id)){
        showToast("Already matched!");
        return;
      }

      // If user taps a card already selected, unselect it
      const selectedAlready = el.classList.contains("selected");
      if(selectedAlready){
        el.classList.remove("selected");
        if(kind === "word") state.selection.wordId = null;
        else state.selection.picId = null;
        return;
      }

      // Clear old selection of same kind
      const prevSel = document.querySelector(`.cardBtn.selected[data-kind="${kind}"]`);
      if(prevSel) prevSel.classList.remove("selected");

      el.classList.add("selected");
      if(kind === "word") state.selection.wordId = id;
      else state.selection.picId = id;

      // attempt match
      if(state.selection.wordId && state.selection.picId){
        const correct = (state.selection.wordId === state.selection.picId);
        if(correct){
          handleCorrect(id);
        }else{
          handleWrong();
        }
      }
    }

    function handleCorrect(id){
      state.correct++;
      state.score += 10;
      beep("good");
      showToast("âœ… Correct! Great job!");
      burstConfetti();

      // mark both cards matched
      state.matchedIds.add(id);

      // disable / style matched cards
      document.querySelectorAll(`.cardBtn[data-id="${id}"]`).forEach(btn=>{
        btn.classList.remove("selected");
        btn.classList.add("matched", "correctFlash");
        btn.disabled = true;
        setTimeout(()=> btn.classList.remove("correctFlash"), 600);
      });

      state.selection.wordId = null;
      state.selection.picId = null;

      const remaining = state.items.length - state.matchedIds.size;
      if(remaining > 0){
        progressText.textContent = `Nice! ${remaining} left.`;
      }else{
        progressText.textContent = `ðŸŽ‰ Round complete! Tap "New Round" to continue.`;
        // Unlock next level automatically if done
        autoUnlockLevel();
      }

      if(state.turnMode) advanceTurn();
      updateHUD();
    }

    function handleWrong(){
      state.wrong++;
      state.score = Math.max(0, state.score - 2);
      beep("bad");
      showToast("âŒ Try again!");

      // shake selected ones
      document.querySelectorAll(".cardBtn.selected").forEach(btn=>{
        btn.classList.add("wrongShake");
        setTimeout(()=> btn.classList.remove("wrongShake"), 500);
      });

      // clear selection after a moment
      setTimeout(()=> clearSelections(), 350);

      if(state.turnMode) advanceTurn();
      updateHUD();
    }

    function advanceTurn(){
      state.currentPlayer++;
      if(state.currentPlayer > state.players) state.currentPlayer = 1;
    }

    function autoUnlockLevel(){
      // If they complete a round on level 1, move to level 2; level 2 -> 3
      if(state.level === 1){
        state.level = 2;
        levelSelect.value = "2";
        showToast("ðŸ”“ Level 2 unlocked!");
      }else if(state.level === 2){
        state.level = 3;
        levelSelect.value = "3";
        showToast("ðŸ”“ Level 3 unlocked!");
      }
      updateHUD();
    }

    /***********************
     * Round / Reset
     ***********************/
    function startNewRound(keepRoundCount=false){
      const count = levelCount(state.level);

      // Choose items for the round.
      // Level 1 leans toward the basic list; later levels mix in everything.
      let pool;
      if(state.level === 1){
        pool = WORD_BANK.slice(0, 10);
      }else if(state.level === 2){
        pool = WORD_BANK.slice(0, 20);
      }else{
        pool = WORD_BANK;
      }
      const pick = shuffle(pool).slice(0, Math.min(count, pool.length));

      state.items = pick.map((x, idx)=> ({
        id: `${state.round}-${idx}-${x.word}`, // unique for the round
        word: x.word,
        emoji: x.emoji,
        hint: x.hint
      }));

      // Map matching by id (word button and picture button share same id)
      // So the correct match is equality of ids.

      if(!keepRoundCount) state.round++;

      renderRound();
    }

    function resetGame(){
      state.level = 1;
      state.round = 1;
      state.score = 0;
      state.correct = 0;
      state.wrong = 0;
      state.turnMode = false;
      state.currentPlayer = 1;
      state.matchedIds = new Set();
      state.selection.wordId = null;
      state.selection.picId = null;

      levelSelect.value = "1";
      turnModeToggle.checked = false;
      updateHUD();

      // Create round 1 (donâ€™t increment round counter during init)
      state.items = [];
      startNewRound(true);
      showToast("Game reset!");
    }

    /***********************
     * Events
     ***********************/
    levelSelect.addEventListener("change", ()=>{
      state.level = Number(levelSelect.value);
      // start a fresh round at chosen level
      showToast(`Level ${state.level} selected`);
      startNewRound(true);
      updateHUD();
    });

    nextRoundBtn.addEventListener("click", ()=>{
      // if previous round completed, this just continues
      showToast("New round!");
      startNewRound(false);
    });

    resetBtn.addEventListener("click", resetGame);

    turnModeToggle.addEventListener("change", ()=>{
      state.turnMode = turnModeToggle.checked;
      state.currentPlayer = 1;
      showToast(state.turnMode ? "Turn-Based Mode ON" : "Turn-Based Mode OFF");
      updateHUD();
    });

    // Make sure voices load on some browsers
    window.speechSynthesis?.addEventListener?.("voiceschanged", ()=>{});

    /***********************
     * Init
     ***********************/
    updateHUD();
    // Start first round without incrementing round number
    startNewRound(true);
  </script>
</body>
</html>
```
